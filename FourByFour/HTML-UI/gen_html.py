# LPZW TRAM8 4x4 firmware
# Offline HTML-based SysEx configurator generator.
# CC BY-NC-ND 4.0 Dmitry S. Baikov
# aka c0ff
# Initially written in early January 2026
#
# https://github.com/c0ff/TRAM8-4x4
#
import argparse
import binascii

CONFIGURATION_FORMAT = 2
CONFIGURATION_LENGTH = 46

def incrange(start, incl_end, step=1):
    return list(range(start, incl_end + step, step))

def mkchan(name, def_chan):
    out = f'<select name="{name}" id="{name}">\n'
    for i in incrange(1,16):
        sel = ' selected' if i == def_chan else ''
        out += f'<option value="{str(i)}"{sel}>Channel {str(i)}</option>\n'
    out+= '</select>'
    return out

def mktrig(name, def_val):
    vals = incrange(1,10) + incrange(15,120,5)
    out = f'<select name="{name}" id="{name}">\n'
    for v in vals:
        sel = ' selected' if v == def_val else ''
        out += f'<option value="{str(v)}"{sel}>{str(v)} ms</option>\n'
    out+= '</select>'
    return out

def mkgatemode(name, def_val):
    vals=[('Gate', 0), ('Trigger', 1), ('RUN gate', 2), ('RESET trigger', 3)]
    out = f'<select name="{name}" id="{name}">\n'
    for v,i in vals:
        sel = ' selected' if i == def_val else ''
        out += f'<option value="{str(i)}"{sel}>{v}</option>\n'
    out+= '</select>'
    return out

def mkgatesrc(name, def_val):
    vals=[('Note On', 0), ('Clock Pulses (24 ppqn)', 1)]
    out = f'<select name="{name}" id="{name}">\n'
    for v,i in vals:
        sel = ' selected' if i == def_val else ''
        out += f'<option value="{str(i)}"{sel}>{v}</option>\n'
    out+= '</select>'
    return out

def mknotes(name, def_val):
    out = f'<select name="{name}" id="{name}">\n'
    notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']
    for i in range(0, 128):
        octave = i // 12
        note = i % 12
        if note == 0:
            out += f'<optgroup label="Octave {str(octave)}">'
        v = f'{notes[note]}{str(octave)}'
        sel = ' selected' if i == def_val else ''
        out += f'<option value="{str(i)}"{sel}>{v} ({str(i)})</option>\n'
        if note == 11:
            out += '</optgroup>'
    out+= '</select>'
    return out

# TODO: add well-known CC names
CCs = {
1 : 'ModWheel',
}
# TODO: add support for 121 All Cotrollers Off
noCCs = set([120, 123])

def mkccs(name, def_val):
    out = f'<select name="{name}" id="{name}">\n'
    for i in range(0, 128):
        if i in noCCs: continue
        ccname = CCs.get(i)
        v = f'{i} ({ccname})' if ccname else f'{i}' 
        sel = ' selected' if i == def_val else ''
        out += f'<option value={i}{sel}>{v}</option>\n'
    out+= '</select>'
    return out
    
def mkgate_html(id, mode, src, note, pulses=0):
    return f'<tr><td></td><td>{id}</td><td>' +\
mkgatemode(f"gate{id}.mode", mode) + '</td><td>' +\
mkgatesrc(f"gate{id}.src", src) + '</td><td>' +\
mknotes(f"gate{id}.note", note) + '</td><td>' +\
f'<input type="number" min=1 max=127 name="gate{id}.pulses" id="gate{id}.pulses" value={pulses} /></td>'+\
f'<td><input type="checkbox" name="gate{id}.usechan" id="gate{id}.usechan" /></td>'+\
'<td>' + mkchan(f"gate{id}.channel", 0) + '</td></tr>\n'
    
def mkgate_js(id):
    return f'document.getElementById("gate{id}.mode").onchange=function(){{CheckGateMode({id});}};\n' +\
           f'document.getElementById("gate{id}.src").onchange=function(){{CheckGateMode({id});}};\n' +\
           f'document.getElementById("gate{id}.usechan").onchange=function(){{CheckGateMode({id});}};\n'+\
           f'//CheckGateMode({id});\n\n'

def mkcvrange(name, def_val):
    vals=[('0-5V', 5), ('0-8V', 8)]
    out = f'<select name="{name}" id="{name}">\n'
    for v,i in vals:
        sel = ' selected' if i == def_val else ''
        out += f'<option value="{str(i)}"{sel}>{v}</option>\n'
    out+= '</select>'
    return out

def mkcvsrc(name, def_val):
    vals=[('Note Velocity', 0), ('Control Change', 1)]
    out = f'<select name="{name}" id="{name}">\n'
    for v,i in vals:
        sel = ' selected' if i == def_val else ''
        out += f'<option value="{str(i)}"{sel}>{v}</option>\n'
    out+= '</select>'
    return out

def mkcv_html(id, src, note, cc=0):
    return f'<tr><td></td><td>{id}</td><td>' +\
mkcvsrc(f"cv{id}.src", src) + '</td><td>' +\
mknotes(f"cv{id}.note", note) + '</td><td>' +\
mkccs(f"cv{id}.cc", cc) + '</td><td>' +\
f'<input type="checkbox" name="cv{id}.usechan" id="cv{id}.usechan" /></td><td>' +\
mkchan(f"cv{id}.channel", 0) + '</td></tr>\n'
    
def mkcv_js(id):
    return f'document.getElementById("cv{id}.src").onchange=function(){{CheckVoltageSrc({id});}}\n' +\
           f'document.getElementById("cv{id}.usechan").onchange=function(){{CheckVoltageSrc({id});}};\n'+\
           f'//CheckVoltageSrc({id});\n\n'


# header
htm = '''
<!DOCTYPE html>
<!-- offline HTML-based SysEx editor for LPZW TRAM8 4x4 Firmware -->
<!-- Generated by gen_html.py -->
<!-- CC BY-NC-ND 4.0 Dmitry S. Baikov -->
<html>
<body>

<p>
'''

htm += f'''
<b>LPZW Tram8 4x4 Firmware.</b> Configuration Format: {CONFIGURATION_FORMAT}<br />
<i>tram8_4x4_fw2.syx loaded by default.</i><br />
'''

htm += '''
<br />
For updates visit: 
<a href="https://github.com/c0ff/TRAM8-4x4">https://github.com/c0ff/TRAM8-4x4</a>
</p>

<hr>
<form name="sysex_in">
<p>Load an existing TRAM8 4x4 SysEx into this form
<input type="file" accept=".syx" onchange="load_sysex(this)">
</form>

<script>
'''

htm += f'''
const CONFIGURATION_FORMAT = {CONFIGURATION_FORMAT};
const CONFIGURATION_LENGTH = {CONFIGURATION_LENGTH};
const CONFIGURATION_FILENAME = "tram8_4x4_fw{CONFIGURATION_FORMAT}_edit.syx";
'''

htm += '''
const syx_head = Uint8Array.fromHex("F000297F5438465700");
const syx_tail = Uint8Array.fromHex("3A303030303030303146460D0AF7");

const cfg_head = Uint8Array.fromHex("900DF00D");
const cfg_tail = Uint8Array.fromHex("BAADF00D");

    
function isEqualArray(a, b) {
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (a[i] != b[i])
            return false;
    return true;
}

function check_syx(sv) {
    const hdr = sv.subarray(0, syx_head.length)
    if (!isEqualArray(hdr, syx_head))
        return false;
    const tail = sv.subarray(sv.length - syx_tail.length);
    if (!isEqualArray(tail, syx_tail))
        return false;
    for (let i = 1; i < sv.length-1; ++i)
        if (sv[i] > 0x7F)
            return false;
    return true;
}

var SyxEx;
var syx_line_offset = [];
var syx_line_length = [];
var syx_bytes;
var syx_cfg_offset;

function is_empty(ch) {
    return ch == 0x00 || ch == 0x0A;
}

function skip_empty(sv, off) {
    for (let i = off; i < sv.length; ++i)
        if (!is_empty(sv[i]))
            return i;
    return sv.length;
}

function report_bad(msg) {
    console.error(msg);
    throw new Error(msg);
}

function debug_log(msg) {
    console.log(msg);
    //window.alert(msg);
}

function from_hex(ch) {
    if (ch >= 0x30 && ch <= 0x39)
        return ch - 0x30;
    else if (ch >= 0x41 && ch <= 0x46)
        return ch - 0x41 + 0x0A;
    else
        return report_bad('invalid hex');
}

function from_2hex(hi, lo) {
    return from_hex(hi) * 16 + from_hex(lo);
}

function decode_line(sv, off) {
    if (sv[off] != 0x3A) // ':'
        return report_bad("Bad line format!");
    const linelen = from_2hex(sv[off+1], sv[off+2]);
    var linepos = syx_bytes.byteLength;
    syx_bytes.resize(linepos + linelen);
    var store_bytes = new Uint8Array(syx_bytes);
    const lineend = off + 1 + (linelen + 4) * 2;
    var chksum = 0;
    for (let i = 1; i < 9; i += 2)
        chksum += from_2hex(sv[off+i], sv[off+i+1]);
    for (let i = off + 9; i < lineend; i += 2) {
        const b = from_2hex(sv[i], sv[i+1]);
        store_bytes[linepos++] = b;
        chksum += b;
    }
    if (linepos != syx_bytes.byteLength)
        return report_bad("Failed to decode the line at " + off + " linepos: " + linepos + " len: " + syx_bytes.byteLength);
    chksum += from_2hex(sv[lineend], sv[lineend + 1]);
    if (chksum & 0xFF)
        return report_bad("Invalid checksum of the line at " + off);
    return linelen;
}

function parse_lines(sv) {
    syx_line_offset.length = 0;
    syx_line_length.length = 0;
    const fw_fin = sv.length - syx_tail.length;
    var off = syx_head.length;
    var total_bytes = 0;
    while (off < fw_fin) {
        off = skip_empty(sv, off);
        if (off >= fw_fin)
            break;
        const linelen = decode_line(sv, off);
        syx_line_offset.push(off);
        syx_line_length.push(linelen);
        off += 1 + (linelen + 5)*2;
        total_bytes += linelen;
        if (!is_empty(sv[off]))
            return report_bad("Bad line len " + linelen + " " + off);
    }
    return total_bytes;
}

function find_cfg(v8) {
    var i = v8.indexOf(cfg_head[0]);
    while (i >= 0) {
        const head = v8.subarray(i, i + cfg_head.length);
        if (!isEqualArray(head, cfg_head)) {
            i = v8.indexOf(cfg_head[0], i + 1);
            continue;
        }
        const tail_pos = i + CONFIGURATION_LENGTH - cfg_tail.length;
        const tail = v8.subarray(tail_pos, tail_pos + cfg_tail.length);
        if (!isEqualArray(tail, cfg_tail)) {
            i = v8.indexOf(cfg_head[0], i + cfg_head.length);
            continue;
        }
        return i;
    }
    return report_bad("Cannot find configuration block!");
}

function parse_channel_map(syx8, map_off, ctl_type, def_chan) {
    var usemask = syx8[map_off];
    for (let i = 0; i < 8; ++i) {
        const id = i + 1;
        const usechan = (usemask >> i) & 1
        document.getElementById(ctl_type + id + ".usechan").checked = usechan;
        const chan = ((syx8[map_off + 1 + (i >> 1)]) >> ((i & 1) ? 4 : 0)) & 0x0F;
        document.getElementById(ctl_type + id + ".channel").value = usechan ? (chan + 1) : def_chan;
    }
}

function parse_cfg(syx8) {
    syx_cfg_offset = find_cfg(syx8);
    debug_log("Found cfg block at " + syx_cfg_offset);
    
    const cfg_off = syx_cfg_offset + cfg_head.length;
    const ver = syx8[cfg_off];
    if (ver != CONFIGURATION_FORMAT)
        return report_bad("Unsupported configuration format: " + ver);

    const cvRange = syx8[cfg_off + 1] >> 4;
    if (cvRange)
        document.getElementById("global.cvrange").value = 8;
    else
        document.getElementById("global.cvrange").value = 5;
    
    const midiChannel = (syx8[cfg_off + 1] & 0x0F) + 1;
    document.getElementById("global.channel").value = midiChannel;

    const triggerLength = syx8[cfg_off + 2];
    document.getElementById("global.triglen").value = triggerLength;
    
    // TODO: if (cvRange): syx8[cfg_off + 3] is CV outputs 5V downscaling mask.
    
    parse_channel_map(syx8, cfg_off + 4, "gate", midiChannel);
    parse_channel_map(syx8, cfg_off + 9, "cv", midiChannel);
    
    // gates
    const gt_off = cfg_off + 14;
    for (let i = 0; i < 8; ++i) {
        const mode  = syx8[gt_off + i*2 + 0];
        const param = syx8[gt_off + i*2 + 1];
        const istrigger = mode & 0x01;
        var modeval = istrigger;
        if (param == 0)
            modeval |= 2;
        const id = i + 1;
        //debug_log("gate:"+id+" mode:"+mode+" param:"+param);
        document.getElementById("gate" + id + ".mode").value = modeval;
        if (mode & 0x02) {
            document.getElementById("gate" + id + ".src").value = 0;
	        document.getElementById("gate" + id + ".note").value = param;
	        //document.getElementById("gate" + id + ".pulses").value = 0;
        } else {
            document.getElementById("gate" + id + ".src").value = 1;
            //document.getElementById("gate" + id + ".note").value = 0;
	        document.getElementById("gate" + id + ".pulses").value = param;
        }
        CheckGateMode(id);
    }
    
    // voltages
    const cv_off = cfg_off + 30;
    for (let i = 0; i < 8; ++i) {
        const note_or_cc = syx8[cv_off + i];
        const isnote = (note_or_cc < 0x80);
        const id = i + 1;
        if (isnote) {
            document.getElementById("cv" + id + ".src").value = 0;
    	    document.getElementById("cv" + id + ".note").value = note_or_cc;
        } else { 
            document.getElementById("cv" + id + ".src").value = 1;
	        document.getElementById("cv" + id + ".cc").value = note_or_cc & 0x7F;
	    }
	    CheckVoltageSrc(id);
    }
}

function do_parse(sv) {
    if (!check_syx(sv))
        return report_bad("Bad food!");
    syx_bytes = new ArrayBuffer(0, { maxByteLength: 65536 });
    const total_bytes = parse_lines(sv);
    parse_cfg(new Uint8Array(syx_bytes));
    SysEx = sv;
    debug_log("Zehr gut! Lines:" + syx_line_length.length + " Bytes: " + total_bytes);
}

function test_identity() {
    var syx8 = new Uint8Array(syx_bytes.slice());
    write_cfg_bytes(syx8);
    do_parse(patch_sysex(syx8));
}

function parse_sysex(sv) {
    try {
        do_parse(sv);
        //test_identity();
    } catch (err) {
        window.alert(err);
        syx_bytes = undefined;
        return;
    }
}

function load_sysex(inp) {
    var fr = new FileReader();
    fr.onload = function() { parse_sysex(new Uint8Array(fr.result)); }
    fr.readAsArrayBuffer(inp.files[0]);
}

// writing config
function write_channel_map(syx8, map_off, ctl_type) {
    var usemask = 0;
    for (let i = 0; i < 8; ++i) {
        const id = i + 1;
        const usechan = document.getElementById(ctl_type + id + ".usechan").checked;
        if (usechan)
            usemask |= 1 << i;
        const chan = document.getElementById(ctl_type + id + ".channel").value - 1;
        const chan_shift = (i & 1) ? 4 : 0;
        const chan_off = map_off + 1 + (i >> 1);
        syx8[chan_off] &= 0x0F << chan_shift; // clear
        if (usechan)
            syx8[chan_off] |= (chan & 0x0F) << chan_shift; // set
    }
    syx8[map_off] = usemask;
}

function write_cfg_bytes(syx8) {
    const cfg_off = syx_cfg_offset + cfg_head.length;
    
    var cvRange = 0;
    if (document.getElementById("global.cvrange").value > 5)
        cvRange = 1;
    const midiChannel = document.getElementById("global.channel").value - 1;
    syx8[cfg_off + 1] = (cvRange << 4) | (midiChannel & 0x0F);

    const triggerLength = document.getElementById("global.triglen").value;
    syx8[cfg_off + 2] = triggerLength;
    
    write_channel_map(syx8, cfg_off + 4, "gate");
    write_channel_map(syx8, cfg_off + 9, "cv");

    // gates
    const gt_off = cfg_off + 14;
    for (let i = 0; i < 8; ++i) {
        var mode;
        var param;
        const id = i + 1;
        const modeval = document.getElementById("gate" + id + ".mode").value;
        if (modeval > 1) {
            mode = modeval & 0x01;
            param = 0;
        } else {
            mode = modeval;
            const isnote = (document.getElementById("gate" + id + ".src").value == 0);
            if (isnote) {
                param = document.getElementById("gate" + id + ".note").value;
                mode |= 0x02;
            }
            else
                param = document.getElementById("gate" + id + ".pulses").value;
        }
        //debug_log("gate:"+id+" mode:"+mode+" param:"+param);
        syx8[gt_off + i*2 + 0] = mode;
        syx8[gt_off + i*2 + 1] = param;
    }  
 
    // voltages
    const cv_off = cfg_off + 30;
    for (let i = 0; i < 8; ++i) {
        var note_or_cc; 
        const id = i + 1;
        const isnote = (document.getElementById("cv" + id + ".src").value == 0);
        if (isnote)
    	    note_or_cc = document.getElementById("cv" + id + ".note").value;
        else
    	    note_or_cc = document.getElementById("cv" + id + ".cc").value | 0x80;
	    syx8[cv_off + i] = note_or_cc;
    }
}

function tohex(nib) {
    if (nib >= 0 && nib <= 9)
        return nib + 0x30;
    else if (nib >= 0x0A && nib <= 0x0F)
        return nib - 0x0A + 0x41;
    else
        return report_bad("Invalid nib for tohex " + nib);
}

function fix_checksum(syx, cfg_line) {
    const off = syx_line_offset[cfg_line];
    const lineend = off + 1 + (syx_line_length[cfg_line] + 4) * 2;
    var chksum = 0;
    for (let i = 1; i < 9; i += 2)
        chksum += from_2hex(syx[off+i], syx[off+i+1]);
    for (let i = off + 9; i < lineend; i += 2) {
        const b = from_2hex(syx[i], syx[i+1]);
        chksum += b;
    }
    const chkb = (-chksum) & 0xFF;
    syx[lineend] = tohex(chkb >> 4);
    syx[lineend + 1] = tohex(chkb & 0x0F);
 
}

function patch_sysex(syx8) {
    var syx = SysEx.slice();
    var cfg_line = 0;
    var cfg_pos = 0;
    var cfg_off = 0;
    while (cfg_off < syx_cfg_offset) {
        const diff = syx_cfg_offset - cfg_off;
        if (syx_line_length[cfg_line] <= diff) {
            cfg_off += syx_line_length[cfg_line];
            ++cfg_line;
        } else {
            cfg_pos = diff;
            cfg_off += diff;
            break;
        }
    }
    //debug_log("cfg_off: " + cfg_off + " cfg_line: " + cfg_line + " cfg_pos: " + cfg_pos);
    var patched_bytes = 0;
    // found the config block start, now patch it
    for (let i = 0; i < CONFIGURATION_LENGTH; ) {
        const avail = syx_line_length[cfg_line] - cfg_pos;
        const todo = Math.min(avail, CONFIGURATION_LENGTH - i);
        //debug_log("todo: " + todo);
        for (let k = 0; k < todo; ++k) {
            const b = syx8[syx_cfg_offset + i + k];
            const hi = tohex(b >> 4);
            const lo = tohex(b & 0x0F);
            const syxpos = syx_line_offset[cfg_line] + 9 + cfg_pos * 2;
            if (syx[syxpos] != hi)
                ++patched_bytes;
            syx[syxpos] = hi;
            if (syx[syxpos+1] != lo)
                ++patched_bytes;
            syx[syxpos + 1] = lo
            ++cfg_pos;
        }
        i += todo;
        if (cfg_pos == syx_line_length[cfg_line] || i == CONFIGURATION_LENGTH) {
            //debug_log("fix_checksum line: " + cfg_line);
            fix_checksum(syx, cfg_line);
            ++cfg_line;
            cfg_pos = 0;
        }
    }
    debug_log("Patched bytes: " + patched_bytes);
    return syx;
}

// https://stackoverflow.com/questions/3665115/how-to-create-a-file-in-memory-for-user-to-download-but-not-through-server/18197341
function save(filename, data) {
    const blob = new Blob([data], {type: 'application/octet-stream'});
    if(window.navigator.msSaveOrOpenBlob) {
        window.navigator.msSaveBlob(blob, filename);
    }
    else{
        const elem = window.document.createElement('a');
        elem.href = window.URL.createObjectURL(blob);
        elem.download = filename;        
        document.body.appendChild(elem);
        elem.click();        
        document.body.removeChild(elem);
        window.URL.revokeObjectURL(elem.href);
    }
}

function test_checksum_fix() {
    var out_syx = SysEx.slice();
    for (let i = 0; i < syx_line_length.length; ++i)
        fix_checksum(out_syx, i);
    return out_syx;
}

function download_sysex() {
    //const out_syx = test_checksum_fix();
    var syx8 = new Uint8Array(syx_bytes.slice());
    write_cfg_bytes(syx8);
    const out_syx = patch_sysex(syx8);
    save(CONFIGURATION_FILENAME, out_syx);
}
</script>
'''

# globals
htm += f'''
<hr>

<p><b>GLOBALS</b></p>
<table>
<tr>
<td>&nbsp;&nbsp;&nbsp;</td>
<td title="Select the input MIDI channel to use for all mapings'">Default MIDI Channel</td>
<td>&nbsp;&nbsp;&nbsp;</td>
<td title="Select the millisecond duration for trigger outputs">Trigger Length</td>
<td>&nbsp;&nbsp;&nbsp;</td>
<td title="Select the maximum Control Voltage value">Control Voltage Range</td>
</tr>
<tr>
<td></td>
<td>{mkchan("global.channel", 0)}</td>
<td></td>
<td>{mktrig("global.triglen", 0)}</td>
<td></td>
<td>{mkcvrange("global.cvrange", 0)}</td>
</tr>
</table>
'''

# gates
htm += f'''
<hr>

<p>
<b>GATE/TRIGGER OUTPUTS</b><br>
<i>NOTE: Gate from a Clock source produces a flip-flop (a square LFO with the period twice the gate duration)</i>
</p>

<table>
<tr>
<td>&nbsp;&nbsp;&nbsp;</td>
<td title="Gate output">Gate Output</td>
<td title="Select gate output mode">Mode</td>
<td title="Select the activation source">Source</td>
<td title="Note Number">Note</td>
<td title="Clock: Number of ticks between activations">Clock Divider</td>
<td title="Note: listen to custom channel number">Use Channel</td>
<td title="Note: custom MIDI channel number">Channel</td>
</tr>
'''

for i in incrange(1, 8):
    htm += mkgate_html(i, 0, 0, 0)

htm+='''
<script language="javascript">
function CheckGateMode(id) {
	const d = (document.getElementById("gate" + id + ".mode").value > 1);
	document.getElementById("gate" + id + ".src").disabled = d;
	if (d) {
	   document.getElementById("gate" + id + ".note").disabled = d;
	   document.getElementById("gate" + id + ".pulses").disabled = d;
	   document.getElementById("gate" + id + ".usechan").disabled = d;
	   document.getElementById("gate" + id + ".channel").disabled = d;
    } else {
	   var isnote = (document.getElementById("gate" + id + ".src").value == 0);
	   document.getElementById("gate" + id + ".note").disabled = !isnote;
	   document.getElementById("gate" + id + ".pulses").disabled = isnote;
	   if (isnote) {
	       var uc = document.getElementById("gate" + id + ".usechan")
	       uc.disabled = false;
	       document.getElementById("gate" + id + ".channel").disabled = !uc.checked;
	   } else {
    	   document.getElementById("gate" + id + ".usechan").disabled = true;
	       document.getElementById("gate" + id + ".channel").disabled = true;
	   }
    }
}
'''

for i in incrange(1, 8):
    htm += mkgate_js(str(i))

htm+='''
</script>
</table>
'''

# control voltages
htm += '''
<hr>

<p>
<b>CONTROL VOLTAGE OUTPUTS</b></p>

<table>
<tr>
<td>&nbsp;&nbsp;&nbsp;</td>
<td title="CV output">CV Output</td>
<td title="Select CV Source">CV Source</td>
<td title="Note Number">Note</td>
<td title="CC number">CC Number</td>
<td title="Listen to custom channel number">Use Channel</td>
<td title="Custom MIDI channel number">Channel</td>
</tr>
'''

for i in incrange(1, 8):
    htm += mkcv_html(i, 0, 0, 0)

htm+='''
<script language="javascript">
function CheckVoltageSrc(id) {
	const isnote = (document.getElementById("cv" + id + ".src").value == 0);
	document.getElementById("cv" + id + ".note").disabled = !isnote;
	document.getElementById("cv" + id + ".cc").disabled = isnote;
	var uc = document.getElementById("cv" + id + ".usechan")
	document.getElementById("cv" + id + ".channel").disabled = !uc.checked;
}
'''

for i in incrange(1, 8):
    htm += mkcv_js(str(i))

htm+='''
</script>
</table>
'''

# footer
def add_footer(htm):
    return htm + '''
<hr>
<form name="sysex_out" onsubmit="download_sysex(); event.preventDefault()">
<input type="submit" value="Get the configured SysEx" onchange="download_sysex()">
</form>
<hr>
<p>LPZW TRAM8 4x4 firmware<br />
CC BY-NC-ND 4.0 Dmitry S. Baikov<br />
<a href="https://github.com/c0ff/TRAM8-4x4">https://github.com/c0ff/TRAM8-4x4</a></p>
</body>
</html>
'''

def add_firmware(htm, fw_file):
    fw = open(fw_file, 'rb').read()
    fw_hex = binascii.hexlify(fw).decode('utf-8')
    ah = f'''
<script>
// default 4x4 Firmware SysEx
const firmware_syx = Uint8Array.fromHex("{fw_hex}");
''' + '''
window.onload = function() { parse_sysex(firmware_syx); };
</script>
'''
    return htm + ah

def main():
    global htm
    ap = argparse.ArgumentParser()
    ap.add_argument('-o', '--output')
    ap.add_argument('--firmware-sysex')
    args = ap.parse_args()
    
    if args.firmware_sysex:
        htm = add_firmware(htm, args.firmware_sysex)
    
    htm = add_footer(htm)
    
    if args.output:
        open(args.output, 'w', encoding='utf8').write(htm)
    else:
        print(htm)
    
if __name__=="__main__":
    main()